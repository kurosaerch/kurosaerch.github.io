const s=e=>e.replaceAll("&#034;",'"').replaceAll("&#038;","&").replaceAll("&#039;","'").replaceAll("&eacute;","Ã©"),o=e=>{try{return new URL(e),!0}catch{return!1}},w=(e,t)=>{try{const n=new URL(e);return n.hostname=t,n.toString()}catch{return e}},l=(e,t)=>{if(!o(e))throw new TypeError("Invalid URL passed to fetchAbortPrevious");if(!c(t))throw new TypeError("Invalid AbortController passed to fetchAbortPrevious");return t&&t.abort(),t=new AbortController,fetch(e,{signal:t.signal})},c=e=>e===null||e instanceof AbortController;let i=null;const f=async e=>{const t=new URL("https://api.rule34.xxx/autocomplete.php");t.searchParams.append("q",e.replaceAll(" ","_"));const n=await l(t.toString(),i);if(n.ok){const r=await n.json();if(Array.isArray(r)){if(r.length===0)throw new Error("No tags found");return r.map(p)}else throw r.message?new Error(r.message):new Error("Invalid tag suggestions received")}else throw new Error("Failed to get tag suggestions")},x=async e=>{const t=new URL("https://api.rule34.xxx/index.php?page=dapi&s=tag&q=index&limit=1");t.searchParams.append("name",e);const r=await(await fetch(t.toString())).text(),a=new DOMParser().parseFromString(r,"text/xml").getElementsByTagName("tag")[0];return g(a.attributes)},p=e=>({label:s(e.value),count:u(e.label),type:"tag"}),u=e=>Number(e.substring(e.lastIndexOf("(")+1,e.length-1)),g=e=>{const t=e.getNamedItem("name"),n=e.getNamedItem("count"),r=e.getNamedItem("type");if(!(t===null||n===null||r===null))return{name:s(t.value),count:Number(n.value),type:m(r.value)}},m=e=>["general","artist","general","copyright","character","metadata"][Number(e)];export{x as a,s as b,l as f,f as g,o as i,w as r};
